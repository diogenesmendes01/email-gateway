// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// ENUMS
// ============================================

enum EmailStatus {
  PENDING
  ENQUEUED
  RECEIVED      // Pipeline: Job recebido
  VALIDATED     // Pipeline: Validações OK
  SENT_ATTEMPT  // Pipeline: Tentando enviar ao SES
  SENT
  FAILED
  RETRYING
  RETRY_SCHEDULED // Pipeline: Agendado para retry
}

enum EventType {
  CREATED
  ENQUEUED
  RECEIVED        // Pipeline: Job recebido
  VALIDATED       // Pipeline: Validado
  SENT_ATTEMPT    // Pipeline: Tentativa de envio
  PROCESSING
  SENT
  FAILED
  RETRYING
  RETRY_SCHEDULED // Pipeline: Agendado para retry
  BOUNCED
  COMPLAINED
  DELIVERED
  VALIDATION_FAILED // Pipeline: Falha na validação
}

// TASK 6.2: Domain Management Enums
enum DomainVerificationStatus {
  PENDING
  VERIFIED
  FAILED
  TEMPORARY_FAILURE
}

enum DKIMVerificationStatus {
  PENDING
  VERIFIED
  FAILED
}

// TASK-023: Webhook System Enums
enum WebhookDeliveryStatus {
  PENDING
  SUCCESS
  FAILED
  RETRYING
}

// TASK-025: Batch Email Enums
enum BatchStatus {
  PROCESSING
  COMPLETED
  PARTIAL
  FAILED
}

// ============================================
// MODELS
// ============================================

model Company {
  id        String   @id @default(cuid())
  name      String
  apiKey    String   @unique @map("api_key")
  apiKeyHash String  @unique @map("api_key_hash") @db.VarChar(128)
  apiKeyPrefix String @map("api_key_prefix") @db.VarChar(20)
  apiKeyCreatedAt DateTime @map("api_key_created_at")
  apiKeyExpiresAt DateTime @map("api_key_expires_at")
  lastUsedAt DateTime? @map("last_used_at")
  isActive  Boolean  @default(true) @map("is_active")
  allowedIps String[] @default([]) @map("allowed_ips")
  rateLimitConfig Json? @map("rate_limit_config")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  recipients   Recipient[]
  emailOutbox  EmailOutbox[]
  emailLogs    EmailLog[]
  idempotencyKeys IdempotencyKey[]
  auditLogs   AuditLog[]
  domains     Domain[]
  webhooks    Webhook[] // TASK-023
  recipientBlocklist RecipientBlocklist[] // TASK-024
  emailBatches EmailBatch[] // TASK-025

  @@map("companies")
}

model Recipient {
  id            String   @id @default(cuid())
  companyId     String   @map("company_id")
  externalId    String?  @map("external_id")
  cpfCnpjHash   String?  @map("cpf_cnpj_hash") @db.VarChar(64)
  cpfCnpjEnc    String?  @map("cpf_cnpj_enc") // Encrypted CPF/CNPJ
  cpfCnpjSalt   String?  @map("cpf_cnpj_salt") // Salt for encryption
  razaoSocial   String?  @map("razao_social") @db.VarChar(150)
  nome          String?  @db.VarChar(120)
  email         String   @db.VarChar(254)
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")
  deletedAt     DateTime? @map("deleted_at")

  // Relations
  company     Company       @relation(fields: [companyId], references: [id], onDelete: Cascade)
  emailOutbox EmailOutbox[]
  emailLogs   EmailLog[]

  @@unique([companyId, externalId])
  // Composite indexes for optimal query performance
  @@index([companyId, cpfCnpjHash, deletedAt]) // Search by CPF/CNPJ hash
  @@index([companyId, email, deletedAt])       // Search by email with soft delete
  @@index([companyId, deletedAt, createdAt])   // List/pagination with soft delete
  @@map("recipients")
}

model EmailOutbox {
  id           String      @id @default(cuid())
  companyId    String      @map("company_id")
  recipientId  String?     @map("recipient_id")
  externalId   String?     @map("external_id") @db.VarChar(64)
  to           String      @db.VarChar(254)
  cc           String[]    @default([])
  bcc          String[]    @default([])
  subject      String      @db.VarChar(150)
  html         String      @db.Text
  replyTo      String?     @map("reply_to") @db.VarChar(254)
  headers      Json?
  tags         String[]    @default([])
  status       EmailStatus @default(PENDING)
  jobId        String?     @unique @map("job_id")
  requestId    String?     @map("request_id") @db.VarChar(128)
  attempts     Int         @default(0)
  lastError    String?     @map("last_error") @db.Text
  createdAt    DateTime    @default(now()) @map("created_at")
  updatedAt    DateTime    @updatedAt @map("updated_at")
  enqueuedAt   DateTime?   @map("enqueued_at")
  processedAt  DateTime?   @map("processed_at")

  // TASK-025: Batch tracking
  batchId      String?     @map("batch_id")

  // Relations
  company   Company     @relation(fields: [companyId], references: [id], onDelete: Cascade)
  recipient Recipient?  @relation(fields: [recipientId], references: [id], onDelete: SetNull)
  emailLog  EmailLog?
  batch     EmailBatch? @relation(fields: [batchId], references: [id], onDelete: SetNull)

  @@index([companyId, status])
  @@index([companyId, externalId])
  @@index([companyId, createdAt])
  @@index([recipientId])
  @@index([batchId], map: "idx_email_outbox_batch") // TASK-025
  // TASK-017: Composite index for dashboard queries
  // Optimizes: WHERE company_id = X AND status = Y ORDER BY created_at DESC
  // Used by dashboard email list, date range filters, and status-based queries
  @@index([companyId, status, createdAt(sort: Desc)], map: "idx_email_outbox_dashboard")
  @@map("email_outbox")
}

model EmailLog {
  id            String      @id @default(cuid())
  outboxId      String      @unique @map("outbox_id")
  companyId     String      @map("company_id")
  recipientId   String?     @map("recipient_id")
  to            String      @db.VarChar(254)
  subject       String      @db.VarChar(150)
  status        EmailStatus
  sesMessageId  String?     @unique @map("ses_message_id") @db.VarChar(128)
  errorCode     String?     @map("error_code") @db.VarChar(64)
  errorReason   String?     @map("error_reason") @db.Text
  attempts      Int         @default(0)
  durationMs    Int?        @map("duration_ms")
  requestId     String?     @map("request_id") @db.VarChar(128)
  createdAt     DateTime    @default(now()) @map("created_at")
  sentAt        DateTime?   @map("sent_at")
  failedAt      DateTime?   @map("failed_at")

  // TASK-024: SES Event Fields
  bounceType            String?   @map("bounce_type") @db.VarChar(32)
  bounceSubtype         String?   @map("bounce_subtype") @db.VarChar(64)
  complaintFeedbackType String?   @map("complaint_feedback_type") @db.VarChar(64)
  deliveryTimestamp     DateTime? @map("delivery_timestamp")

  // Relations
  company     Company      @relation(fields: [companyId], references: [id], onDelete: Cascade)
  recipient   Recipient?   @relation(fields: [recipientId], references: [id], onDelete: SetNull)
  outbox      EmailOutbox  @relation(fields: [outboxId], references: [id], onDelete: Cascade)
  events      EmailEvent[]

  @@index([companyId, status])
  @@index([companyId, createdAt])
  @@index([recipientId])
  @@index([sesMessageId])
  // TASK 9.2: Sorting indexes for dashboard performance
  @@index([status, createdAt])
  @@index([sentAt])
  @@index([attempts, createdAt])
  @@index([durationMs])
  @@map("email_logs")
}

model EmailEvent {
  id          String    @id @default(cuid())
  emailLogId  String    @map("email_log_id")
  type        EventType
  metadata    Json?
  createdAt   DateTime  @default(now()) @map("created_at")

  // Relations
  emailLog EmailLog @relation(fields: [emailLogId], references: [id], onDelete: Cascade)

  @@index([emailLogId, createdAt])
  @@map("email_events")
}

model IdempotencyKey {
  id         String   @id @default(cuid())
  companyId  String   @map("company_id")
  key        String   @db.VarChar(128)
  outboxId   String   @map("outbox_id")
  requestHash String  @map("request_hash") @db.VarChar(64)
  createdAt  DateTime @default(now()) @map("created_at")
  expiresAt  DateTime @map("expires_at")

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, key])
  @@index([expiresAt])
  @@map("idempotency_keys")
}

model AuditLog {
  id        String   @id @default(cuid())
  companyId String   @map("company_id")
  userId    String?  @map("user_id") @db.VarChar(128)
  action    String   @db.VarChar(64)
  resource  String   @db.VarChar(64)
  resourceId String? @map("resource_id") @db.VarChar(128)
  ipAddress String?  @map("ip_address") @db.VarChar(45)
  userAgent String?  @map("user_agent") @db.Text
  metadata  Json?
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@index([companyId, createdAt])
  @@index([action, createdAt])
  @@index([resource, resourceId])
  @@map("audit_logs")
}

// TASK 6.2: Domain Management Model
model Domain {
  id                    String                    @id @default(cuid())
  companyId             String                    @map("company_id")
  domain                String                    @db.VarChar(253)
  status                DomainVerificationStatus  @default(PENDING)
  dkimStatus            DKIMVerificationStatus    @default(PENDING)
  dkimTokens            String[]                  @default([]) @map("dkim_tokens")
  spfRecord             String?                   @map("spf_record") @db.VarChar(255)
  dkimRecords           Json?                     @map("dkim_records")
  dmarcRecord           String?                   @map("dmarc_record") @db.VarChar(255)
  lastChecked           DateTime?                 @map("last_checked")
  lastVerified          DateTime?                 @map("last_verified")
  errorMessage          String?                   @map("error_message") @db.Text

  // TASK-016: Domain warm-up configuration
  warmupEnabled         Boolean                   @default(false) @map("warmup_enabled")
  warmupStartDate       DateTime?                 @map("warmup_start_date")
  warmupConfig          Json?                     @map("warmup_config")

  isProductionReady     Boolean                   @default(false) @map("is_production_ready")
  createdAt             DateTime                  @default(now()) @map("created_at")
  updatedAt             DateTime                  @updatedAt @map("updated_at")

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, domain])
  @@index([companyId, status])
  @@index([domain])
  @@map("domains")
}

// TASK-023: Webhook System
model Webhook {
  id        String   @id @default(cuid())
  companyId String   @map("company_id")
  url       String   @db.VarChar(2048)
  secret    String   @db.VarChar(64)
  events    String[] @default([])
  isActive  Boolean  @default(true) @map("is_active")
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  // Relations
  company    Company             @relation(fields: [companyId], references: [id], onDelete: Cascade)
  deliveries WebhookDelivery[]

  @@index([companyId, isActive], map: "idx_webhooks_company_active")
  @@map("webhooks")
}

model WebhookDelivery {
  id           String                @id @default(cuid())
  webhookId    String                @map("webhook_id")
  eventType    String                @map("event_type") @db.VarChar(64)
  payload      Json
  status       WebhookDeliveryStatus @default(PENDING)
  responseCode Int?                  @map("response_code")
  responseBody String?               @map("response_body") @db.Text
  attempts     Int                   @default(0)
  nextRetryAt  DateTime?             @map("next_retry_at")
  deliveredAt  DateTime?             @map("delivered_at")
  createdAt    DateTime              @default(now()) @map("created_at")

  // Relations
  webhook Webhook @relation(fields: [webhookId], references: [id], onDelete: Cascade)

  @@index([webhookId, createdAt(sort: Desc)], map: "idx_webhook_deliveries_webhook")
  @@index([status, nextRetryAt], map: "idx_webhook_deliveries_status")
  @@map("webhook_deliveries")
}

// TASK-024: Recipient Blocklist (Hard Bounces & Complaints)
model RecipientBlocklist {
  id             String   @id @default(cuid())
  companyId      String   @map("company_id")
  email          String   @db.VarChar(254)
  reason         String   @db.VarChar(32) // 'hard_bounce', 'soft_bounce', 'complaint'
  bounceType     String?  @map("bounce_type") @db.VarChar(32)
  bounceSubtype  String?  @map("bounce_subtype") @db.VarChar(64)
  sesMessageId   String?  @map("ses_message_id") @db.VarChar(128)
  blockedAt      DateTime @default(now()) @map("blocked_at")
  metadata       Json?

  // Relations
  company Company @relation(fields: [companyId], references: [id], onDelete: Cascade)

  @@unique([companyId, email], map: "idx_blocklist_company_email")
  @@index([reason, blockedAt], map: "idx_blocklist_reason")
  @@map("recipient_blocklist")
}

// TASK-025: Email Batch Tracking
model EmailBatch {
  id             String      @id @default(cuid())
  companyId      String      @map("company_id")
  status         BatchStatus @default(PROCESSING)
  totalEmails    Int         @map("total_emails")
  processedCount Int         @default(0) @map("processed_count")
  successCount   Int         @default(0) @map("success_count")
  failedCount    Int         @default(0) @map("failed_count")
  metadata       Json?
  createdAt      DateTime    @default(now()) @map("created_at")
  updatedAt      DateTime    @updatedAt @map("updated_at")
  completedAt    DateTime?   @map("completed_at")

  // Relations
  company Company       @relation(fields: [companyId], references: [id], onDelete: Cascade)
  emails  EmailOutbox[]

  @@index([companyId, createdAt(sort: Desc)], map: "idx_email_batches_company")
  @@index([status, createdAt], map: "idx_email_batches_status")
  @@map("email_batches")
}
